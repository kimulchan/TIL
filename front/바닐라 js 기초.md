## 키워드(keyword) 예약어(reserved)

1. 변수명, 함수명으로 사용할 수 없음

## 식별자 (identifier)

1. 함수의 이름 변수의 이름 등 
2. 대소문자 구분
3. 유니코드 문자 와 $, _, 숫자(0~9) 사용가능 (숫자로 시작 불가)
4. 예약어 , 공백은 사용 불가
5. 역할에 맞는 이름을 지어주기

## 주석(comments)

1. 소스 코드에 무시되는 부분
2. 소스 코드 이해에 도움을 줌

## 변수와 상수(variable and constans)(블록 스코프)

1. const  상수를 지칭하는 이름
2. let 변수를 지칭하는 이름
3. 블록({})안에 있는 변수는 블록 밖에는 영향을 주지 않음
4. 블록 바깥에서 선언된 변수는 블록 안에 쓸 수 있음

## var 의 유효 범위 (함수 스코프)

1. 요즘은 잘 사용되지 않고 블록 스코프를 많이 이용함
2. 함수에서만 구분되는 스코프 

## var 과 호이스팅(Hoisting)

1. 아래에 선언된 함수를 위에서 호출된 상황 var도 포함이 됨

## 자료형 (Data Type)

- 자바 스크립트는 기본적으로 동적타이핑이다 (변수가 가지는 고정 타입이 없음)

- ### 데이터 타입

  ​	타입을 알아볼땐 (typeof로)

  ​	새로운 객체를 생성할때 (new로)

  - 기본타입
    1. boolean(True, False 참과 거짓을 의미)
    2. Null(값이 없는 것을 뜻함(object 형식))
    3. Undefined(변수에 아무 값도 할당하지 않은 것)(null 값과 ==으로 비교하면 참,===은 거짓)
    4. Number(숫자),(Number 함수로 형 변환이 가능함,숫자 변환이 불가능할때 NaN 출력)
    5. String(문자),( ' 와 " 둘다 사용 가능),(+을 통해 문자를 합칠 수 있음),(``로 자바스크립트 표현식 사용 가능)
    6. Symbol(ECMA),(항상 함수를 호출하는 것으로 사용 Symbol (); 형태로 사용),(보통 고유한 값을 만들때 사용), (인자가 같아도 선언이 됨)
  - 객체(Object)

## 조건문

1. 표현식이 거짓으로 평가될때(Falsy)
   - false
   - 0
   - null
   - undifined
   - NaN
2. 표현식이 참으로 평가될때(Truethy)
   - true
   - 0이 아닌 숫자
   - 빈 문자열이 아닌 문자열
   - null, undifined,NaN 이 아닌 모든 객체들
3. && 평가자는 앞에 연산자부터 평가하기 때문에 거짓이면 뒤에 연산자는 평가를 하지 않는다
4. ||평가자는 앞에 연산자가 참일경우 뒤에 연산자는 평가하지 않는다
5. 삼항연산자(?)는 중괄호를 사용할 수 없는 문법이기 때문에 하나의 표현식만 가능

## 반복문

1. for of(iterable)
2. for in(모든 프로퍼티) 프로토 타입안에 프로퍼티를 설정하면 프로퍼티 안에 있는 프로퍼티가 나올수 있는 단점이 있음

## 함수(function)

1. function 함수이름(){}(선언적 function),(호이스팅 가능)
2. const 변수 이름 = function(){}(익명함수를 만들어 변수에 할당),(호이스팅이 되지 않음)
3. const  변수 이름 = new Function(); (메개변수로 문자를 받음 메개변수가 끝나면 리턴을 하는 문자열을 만듬),(전역변수를 받아 사용을 함),(보통 사용하지 않음)
4. errow function(=>)
5. new 함수 (); (생성자 함수)
   1. this :객체로 만들어졌을때 객체를 가르킴
   2. arrow 함수에서는 this 가 형성되지 않음
6. 함수를 호출하면 함수를 만들어서 리턴함
7. 함수를 호출할때 인자로 하여 함수를 호출(콜백 함수)함수 안에 있는 함수 호출 가능

## 객체(Object)

1. 함수와 클래스(틀)로 만들어냄
2. (생성자)함수로 만드는 법: new function 함수이름(객체이름) (){}
3. 객체 속성 추가(property)
   - 값을 속성으로 넣기 (this . keyname)
   - 객체 안에 함수 선언 function a (){funtion b (){}} 호출 : a().b();
4. new object 로 객체 만들기
   - 변수 = new Object ()
   - 리터럴 객체 : 문자 그대로 선언한 객체
5. 프로토타입 체인
   - 인스턴스(instance) : 실제적인 객체 형태
   - 프로토타입 안에 함수를 선언할 수 있음
6. 프로토타입 으로 객체 확장
   - 프로토 타입으로 객체를 확장할 수 있음 ex) a.prototype  =b.prototype (b 에 들어있는 값을 a 에게 줌 원래 a 에 들어있던 값은 그대로 있음)
7. 객체 리터럴은 객체를 직접 설정하는 것
8. 표준 내장 객체(이미 만들어 있는것)
   - object
   - Array(배열)
   - 표준 내장 객체를 따로 확인해야 함

## 클래스(class)

1. 기존의 프로토 타입기반의 방식을 더욱 명료하게 활용할수 있는 도움

2. 선언적 방식, 변수에 할당을 할 수 있음 (new 변수명()) 으로 실행 (함수처럼 실행)

3. 호이스팅이 일어나지 않음

4. constructor(생성자)

   - class 가 생성될 때 실행할 수 있음 construtor(); 로 사용

5. 맴버 변수 (객체의 프로퍼티)

   - 일반 선언 방식으로 할 수 있음

   - constructor 방식으로 맴버 변수를 넣어 줄 수 있음

6. 맴버 함수

   - 함수의 이름 ,괄호, 중괄호로 맴버 함수 설정 가능
   - 맴버 변수 처럼 이름에 함수를 할당할 수 있음

7. get , set

   - 직접 맴버 변수를 바꾸지 않고 바꾸는 방법
   - set :안에 있는 맴버 변수를 바꾸어 줌 객체 이름.(set 함수 이름='바꿀 값')으로 함
   - get :받아온 값을 밖으로 출력할때 쓰이는 함수 return 으로 출력함

8. static 변수, 함수 설정

   - 객체가 아님 class 의 변수와 상수
   - static 변수명,함수명 으로 선언
   - class 의 변수로 this없이 접근 가능
   - 맴버 변수에 접근 안됨
   - 객체로 바꾸었을때 접근이 안됨

9. extends(상속)

   - 부모의 맴버 함수와 변수를 자식에게 그대로 실행할 수 있음
   - class 자식 extends 부모 로 실행

10. override(클래스의 상속 맴버 변수 및 함수 오버라이딩, 추가)

    - 부모와 똑같은 이름의 변수와 함수 이름을 자식이 선언했을 때 자식이 덮어쓸 수 있음

11. super(클래스의 상속 생성자 함수 변경)

    - 자식이 부모의 함수에 값을 추가하기 전 선언해 줌으로써 부모의 값을 그대로 받아옴

## promise

1. 전역 객체에 있는 함수
2. excutor
   - resolve 와 reject 로 구성됨
   - 함수를 실행할때 데이터를 보낼 수 있음
3. promise 객체를 만드는 순간 pending(대기) 상태가 됨
4. resolve 함수를 실행하면  fulfilled(이행) 상태가 됨
5. reject 함수를 실행하면 rejected (거부) 상태가 됨
6. then 은fulfilled상태일때 실행
7. catch 는 rejected (거부)상태일때 실행
8. new Error('이유')함수로 애러객체를 로그로 찍을 수 있음
9. .finally()함수로 최종적인 로그로 실행할 것을 실행할 수 있음
10. callback 지옥이 발생하지 않기 위해 then 을 써 간결하게 코드를 짤 수 있음
11. promise.resolve,promise.reject 는 바로 이행되거나 거부가 된다
12. promise.all으로  미리 만들어진 promise 들이 전부 fulfilled 상태가 되었을 때 실행이 됨(배열 형태로 프로미스 객체를 받음)
13. promise.race 으로 미리 만들어진 promise 들 중 제일 처음 fulfilled 상태가 되었을때 실행이 됨(배열 형태로 프로미스 객체를 받음)

## async-await

1. promise 함수 기반임
2. await 로 promise 에서 리턴된 값을 불러올 수 있음
3. await 를 사용하려면 async 함수 안에서 사용되어야 한다
4. 비동기 처리가 밑으로 흘러가게 표현을 할 수 있음
5. 정상적으로 처리가 된다면 try 로 거부를 했다면 catch 로 처리가 가능함
6. async 가 붙은 함수들이 리턴을 할 때 promise.resolve 함수로 감싸서 리턴됨 